<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-1f106bab-7158-467d-85b3-c001909c6848"></attachment><h2>搭建模型第一步：你需要预习的NumPy基础都在这了</h2><p><br></p><p class="ql-align-center"><strong>基础知识</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">NumPy 主要的运算对象为同质的多维数组，即由同一类型元素（一般是数字）组成的表格，且所有元素通过正整数元组进行索引。在 NumPy 中，维度 (dimension) 也被称之为轴线（axes)。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">比如坐标点 [1, 2, 1] 有一个轴线。这个轴上有 3 个点，所以我们说它的长度（length）为 3。而如下数组（array）有 2 个轴线，长度同样为 3。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">[[&nbsp;1.,&nbsp;0.,&nbsp;0.],
[&nbsp;0.,&nbsp;1.,&nbsp;2.]]
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">NumPy 的数组类（array class）叫做 ndarray，同时我们也常称其为数组（array）。注意 numpy.array 和标准 Python 库中的类 array.array 是不同的。标准 Python 库中的类 array.array 只处理一维的数组，提供少量的功能。ndarray 还具有如下很多重要的属性：</p><p class="ql-align-justify"><br></p><ul><li class="ql-align-justify">ndarray.ndim：显示数组的轴线数量（或维度）。</li><li class="ql-align-justify">ndarray.shape：显示在每个维度里数组的大小。如 n 行 m 列的矩阵，它的 shape 就是（n,m)。</li></ul><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt;&nbsp;b.shape
(2,&nbsp;3)
</pre><p class="ql-align-justify"><br></p><ul><li class="ql-align-justify">ndarray.size：数组中所有元素的总量，相当于数组的 shape 中所有元素的乘积，例如矩阵的元素总量为行与列的乘积。</li></ul><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt;&nbsp;b.size
6

</pre><ul><li class="ql-align-justify">ndarray.dtype：显示数组元素的类型。Python 中的标准 type 函数同样可以用于显示数组类型，NumPy 有它自己的类型如：numpy.int32, numpy.int16, 和 numpy.float64，其中「int」和「float」代表数据的种类是整数还是浮点数，「32」和「16」代表这个数组的字节数（存储大小）。</li><li class="ql-align-justify">ndarray.itemsize：数组中每个元素的字节存储大小。例如元素类型为 float64 的数组，其 itemsize 为 8（=64/8）。</li></ul><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;import&nbsp;numpy&nbsp;as&nbsp;np
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(15).reshape(3,&nbsp;5)
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;2,&nbsp;&nbsp;3,&nbsp;&nbsp;4],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;5,&nbsp;&nbsp;6,&nbsp;&nbsp;7,&nbsp;&nbsp;8,&nbsp;&nbsp;9],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[10,&nbsp;11,&nbsp;12,&nbsp;13,&nbsp;14]])
&gt;&gt;&gt;&nbsp;a.shape
(3,&nbsp;5)
&gt;&gt;&gt;&nbsp;a.ndim
2
&gt;&gt;&gt;&nbsp;a.dtype.name
'int64'
&gt;&gt;&gt;&nbsp;a.itemsize
8
&gt;&gt;&gt;&nbsp;a.size
15
&gt;&gt;&gt;&nbsp;type(a)
&lt;type&nbsp;'numpy.ndarray'&gt;
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([6,&nbsp;7,&nbsp;8])
&gt;&gt;&gt;&nbsp;b
array([6,&nbsp;7,&nbsp;8])
&gt;&gt;&gt;&nbsp;type(b)
&lt;type&nbsp;'numpy.ndarray'&gt;
</pre><p class="ql-align-center"><br></p><p class="ql-align-center"><strong>创建数组</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">NumPy 有很多种创建数组的方法。比如，你可以用 Python 的列表（list）来创建 NumPy 数组，其中生成的数组元素类型与原序列相同。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;import&nbsp;numpy&nbsp;as&nbsp;np
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([2,3,4])
&gt;&gt;&gt;&nbsp;a
array([2,&nbsp;3,&nbsp;4])
&gt;&gt;&gt;&nbsp;a.dtype
dtype('int64')
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([1.2,&nbsp;3.5,&nbsp;5.1])
&gt;&gt;&gt;&nbsp;b.dtype
dtype('float64')
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">一个常见的误差（error）在于调用 array 时使用了多个数值参数，而正确的方法应该是用「[]」来定义一个列表的数值而作为数组的一个参数。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array(1,2,3,4)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;WRONG
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([1,2,3,4])&nbsp;&nbsp;#&nbsp;RIGHT

</pre><p class="ql-align-justify">array 将序列中的序列转换为二维的数组，序列中的序列中的序列转换为三维数组，以此类推。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([(1.5,2,3),&nbsp;(4,5,6)])
&gt;&gt;&gt;&nbsp;b
array([[&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;,&nbsp;&nbsp;3.&nbsp;],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4.&nbsp;,&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;6.&nbsp;]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">数组的类型也可以在创建时指定清楚：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([(1.5,2,3),&nbsp;(4,5,6)])
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;np.array(&nbsp;[&nbsp;[1,2],&nbsp;[3,4]&nbsp;],&nbsp;dtype=complex&nbsp;)
&gt;&gt;&gt;&nbsp;c
array([[&nbsp;1.+0.j,&nbsp;&nbsp;2.+0.j],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;3.+0.j,&nbsp;&nbsp;4.+0.j]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">一般数组的内部元素初始是未知的，但它的大小是已知的。因此，NumPy 提供了一些函数可以创建有初始数值的占位符数组，这样可以减少不必要的数组增长及运算成本。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">函数 zeros 可创建一个内部元素全是 0 的数组，函数 ones 可创建一个内部元素全是 1 的数组，函数 empty 可创建一个初始元素为随机数的数组，具体随机量取决于内存状态。默认状态下，创建数组的数据类型（dtype）一般是 float64。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;np.zeros(&nbsp;(3,4)&nbsp;)
array([[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]])
&gt;&gt;&gt;&nbsp;np.ones(&nbsp;(2,3,4),&nbsp;dtype=np.int16&nbsp;)&nbsp;&nbsp;&nbsp;#&nbsp;dtype&nbsp;can&nbsp;also&nbsp;be&nbsp;specified
array([[[&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1]]],&nbsp;dtype=int16)
&gt;&gt;&gt;&nbsp;np.empty(&nbsp;(2,3)&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;uninitialized,&nbsp;output&nbsp;may&nbsp;vary
array([[&nbsp;&nbsp;3.73603959e-262,&nbsp;&nbsp;&nbsp;6.02658058e-154,&nbsp;&nbsp;&nbsp;6.55490914e-260],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;5.30498948e-313,&nbsp;&nbsp;&nbsp;3.14673309e-307,&nbsp;&nbsp;&nbsp;1.00000000e+000]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">为了创建数列，NumPy 提供一个与 range 类似的函数来创建数组：arange。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;np.arange(&nbsp;10,&nbsp;30,&nbsp;5&nbsp;)
array([10,&nbsp;15,&nbsp;20,&nbsp;25])
&gt;&gt;&gt;&nbsp;np.arange(&nbsp;0,&nbsp;2,&nbsp;0.3&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;it&nbsp;accepts&nbsp;float&nbsp;arguments
array([&nbsp;0.&nbsp;,&nbsp;&nbsp;0.3,&nbsp;&nbsp;0.6,&nbsp;&nbsp;0.9,&nbsp;&nbsp;1.2,&nbsp;&nbsp;1.5,&nbsp;&nbsp;1.8])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">当 arange 使用浮点型参数时，因为浮点精度的有限性，arange 不能判断有需要创建的数组多少个元素。在这种情况下，换成 linspace 函数可以更好地确定区间内到底需要产生多少个数组元素。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;from&nbsp;numpy&nbsp;import&nbsp;pi
&gt;&gt;&gt;&nbsp;np.linspace(&nbsp;0,&nbsp;2,&nbsp;9&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;9&nbsp;numbers&nbsp;from&nbsp;0&nbsp;to&nbsp;2
array([&nbsp;0.&nbsp;&nbsp;,&nbsp;&nbsp;0.25,&nbsp;&nbsp;0.5&nbsp;,&nbsp;&nbsp;0.75,&nbsp;&nbsp;1.&nbsp;&nbsp;,&nbsp;&nbsp;1.25,&nbsp;&nbsp;1.5&nbsp;,&nbsp;&nbsp;1.75,&nbsp;&nbsp;2.&nbsp;&nbsp;])
&gt;&gt;&gt;&nbsp;x&nbsp;=&nbsp;np.linspace(&nbsp;0,&nbsp;2*pi,&nbsp;100&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;useful&nbsp;to&nbsp;evaluate&nbsp;function&nbsp;at&nbsp;lots&nbsp;of&nbsp;points
&gt;&gt;&gt;&nbsp;f&nbsp;=&nbsp;np.sin(x)
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, numpy.random.rand, numpy.random.randn, fromfunction, fromfile&nbsp;（这些函数也可以创建数组，有时间可以尝试解释）</p><p class="ql-align-justify"><br></p><p class="ql-align-center"><strong>输出数组</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">当你输出一个数组时，NumPy 显示这个数组的方式和嵌套列表是相似的。但将数组打印到屏幕需要遵守以下布局：</p><p class="ql-align-justify"><br></p><ul><li class="ql-align-justify">最后一个轴由左至右打印</li><li class="ql-align-justify">倒数第二个轴为从上到下打印</li><li class="ql-align-justify">其余的轴都是从上到下打印，且每一块之间都通过一个空行分隔</li></ul><p class="ql-align-justify"><br></p><p class="ql-align-justify">如下所示，一维数组输出为一行、二维为矩阵、三维为矩阵列表。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;1d&nbsp;array
&gt;&gt;&gt;&nbsp;print(a)
[0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5]
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.arange(12).reshape(4,3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;2d&nbsp;array
&gt;&gt;&gt;&nbsp;print(b)
[[&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;2]
&nbsp;[&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5]
&nbsp;[&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8]
&nbsp;[&nbsp;9&nbsp;10&nbsp;11]]
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;np.arange(24).reshape(2,3,4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;3d&nbsp;array
&gt;&gt;&gt;&nbsp;print(c)
[[[&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3]
&nbsp;&nbsp;[&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7]
&nbsp;&nbsp;[&nbsp;8&nbsp;&nbsp;9&nbsp;10&nbsp;11]]
&nbsp;[[12&nbsp;13&nbsp;14&nbsp;15]
&nbsp;&nbsp;[16&nbsp;17&nbsp;18&nbsp;19]
&nbsp;&nbsp;[20&nbsp;21&nbsp;22&nbsp;23]]]
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">上述使用的 reshape 函数可指定数组的行列数，并将所有元素按指定的维度数排列，详细介绍请看后面章节。在数组的打印中，如果一个数组所含元素数太大，NumPy 会自动跳过数组的中间部分，只输出两边。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;print(np.arange(10000))
[&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;...,&nbsp;9997&nbsp;9998&nbsp;9999]
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;print(np.arange(10000).reshape(100,100))
[[&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;...,&nbsp;&nbsp;&nbsp;97&nbsp;&nbsp;&nbsp;98&nbsp;&nbsp;&nbsp;99]
&nbsp;[&nbsp;100&nbsp;&nbsp;101&nbsp;&nbsp;102&nbsp;...,&nbsp;&nbsp;197&nbsp;&nbsp;198&nbsp;&nbsp;199]
&nbsp;[&nbsp;200&nbsp;&nbsp;201&nbsp;&nbsp;202&nbsp;...,&nbsp;&nbsp;297&nbsp;&nbsp;298&nbsp;&nbsp;299]
&nbsp;...,
&nbsp;[9700&nbsp;9701&nbsp;9702&nbsp;...,&nbsp;9797&nbsp;9798&nbsp;9799]
&nbsp;[9800&nbsp;9801&nbsp;9802&nbsp;...,&nbsp;9897&nbsp;9898&nbsp;9899]
&nbsp;[9900&nbsp;9901&nbsp;9902&nbsp;...,&nbsp;9997&nbsp;9998&nbsp;9999]]
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">如果想要 NumPy 输出整个数组，你可以用 set_printoptions 改变输出设置。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;np.set_printoptions(threshold=np.nan)
</pre><p class="ql-align-justify"><br></p><p class="ql-align-center"><strong>基础运算</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">数组中的算术运算一般是元素级的运算，运算结果会产生一个新的数组。如下所示减法、加法、平方、对应元素乘积和逻辑运算都是元素级的操作。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array(&nbsp;[20,30,40,50]&nbsp;)
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.arange(&nbsp;4&nbsp;)
&gt;&gt;&gt;&nbsp;b
array([0,&nbsp;1,&nbsp;2,&nbsp;3])
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;a-b
&gt;&gt;&gt;&nbsp;c
array([20,&nbsp;29,&nbsp;38,&nbsp;47])
&gt;&gt;&gt;&nbsp;b**2
array([0,&nbsp;1,&nbsp;4,&nbsp;9])
&gt;&gt;&gt;&nbsp;10*np.sin(a)
array([&nbsp;9.12945251,&nbsp;-9.88031624,&nbsp;&nbsp;7.4511316&nbsp;,&nbsp;-2.62374854])
&gt;&gt;&gt;&nbsp;a&lt;35
array([&nbsp;True,&nbsp;True,&nbsp;False,&nbsp;False])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">不同于许多科学计算语言，乘法算子 * 或 multiple 函数在 NumPy 数组中用于元素级的乘法运算，矩阵乘法可用 dot 函数或方法来执行。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;np.array(&nbsp;[[1,1],
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,1]]&nbsp;)
&gt;&gt;&gt;&nbsp;B&nbsp;=&nbsp;np.array(&nbsp;[[2,0],
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,4]]&nbsp;)
&gt;&gt;&gt;&nbsp;A*B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;elementwise&nbsp;product
array([[2,&nbsp;0],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;4]])
&gt;&gt;&gt;&nbsp;A.dot(B)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;matrix&nbsp;product
array([[5,&nbsp;4],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4]])
&gt;&gt;&gt;&nbsp;np.dot(A,&nbsp;B)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;another&nbsp;matrix&nbsp;product
array([[5,&nbsp;4],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">有一些操作，如 += 和 *=，其输出结果会改变一个已存在的数组，而不是如上述运算创建一个新数组。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.ones((2,3),&nbsp;dtype=int)
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.random.random((2,3))
&gt;&gt;&gt;&nbsp;a&nbsp;*=&nbsp;3
&gt;&gt;&gt;&nbsp;a
array([[3,&nbsp;3,&nbsp;3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;3,&nbsp;3]])
&gt;&gt;&gt;&nbsp;b&nbsp;+=&nbsp;a
&gt;&gt;&gt;&nbsp;b
array([[&nbsp;3.417022&nbsp;&nbsp;,&nbsp;&nbsp;3.72032449,&nbsp;&nbsp;3.00011437],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;3.30233257,&nbsp;&nbsp;3.14675589,&nbsp;&nbsp;3.09233859]])
&gt;&gt;&gt;&nbsp;a&nbsp;+=&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;b&nbsp;is&nbsp;not&nbsp;automatically&nbsp;converted&nbsp;to&nbsp;integer&nbsp;type
Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):
&nbsp;&nbsp;...
TypeError:&nbsp;Cannot&nbsp;cast&nbsp;ufunc&nbsp;add&nbsp;output&nbsp;from&nbsp;dtype('float64')&nbsp;to&nbsp;dtype('int64')&nbsp;with&nbsp;casting&nbsp;rule&nbsp;'same_kind'

</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">当操作不同数据类型的数组时，最后输出的数组类型一般会与更普遍或更精准的数组相同（这种行为叫做 Upcasting）。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.ones(3,&nbsp;dtype=np.int32)
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.linspace(0,pi,3)
&gt;&gt;&gt;&nbsp;b.dtype.name
'float64'
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;a+b
&gt;&gt;&gt;&nbsp;c
array([&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;2.57079633,&nbsp;&nbsp;4.14159265])
&gt;&gt;&gt;&nbsp;c.dtype.name
'float64'
&gt;&gt;&gt;&nbsp;d&nbsp;=&nbsp;np.exp(c*1j)
&gt;&gt;&gt;&nbsp;d
array([&nbsp;0.54030231+0.84147098j,&nbsp;-0.84147098+0.54030231j,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.54030231-0.84147098j])
&gt;&gt;&gt;&nbsp;d.dtype.name
'complex128'

</pre><p class="ql-align-justify">许多一元运算，如计算数组中所有元素的总和，是属于 ndarray 类的方法。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.random.random((2,3))
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;0.18626021,&nbsp;&nbsp;0.34556073,&nbsp;&nbsp;0.39676747],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.53881673,&nbsp;&nbsp;0.41919451,&nbsp;&nbsp;0.6852195&nbsp;]])
&gt;&gt;&gt;&nbsp;a.sum()
2.5718191614547998
&gt;&gt;&gt;&nbsp;a.min()
0.1862602113776709
&gt;&gt;&gt;&nbsp;a.max()
0.6852195003967595

</pre><p class="ql-align-justify">默认状态下，这些运算会把数组视为一个数列而不论它的 shape。然而，如果在指定 axis 参数下，你可以指定针对哪一个维度进行运算。如下 axis=0 将针对每一个列进行运算，例如 b.sum(axis=0) 将矩阵 b 中每一个列的所有元素都相加为一个标量。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.arange(12).reshape(3,4)
&gt;&gt;&gt;&nbsp;b
array([[&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;2,&nbsp;&nbsp;3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4,&nbsp;&nbsp;5,&nbsp;&nbsp;6,&nbsp;&nbsp;7],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8,&nbsp;&nbsp;9,&nbsp;10,&nbsp;11]])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;b.sum(axis=0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;sum&nbsp;of&nbsp;each&nbsp;column
array([12,&nbsp;15,&nbsp;18,&nbsp;21])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;b.min(axis=1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;min&nbsp;of&nbsp;each&nbsp;row
array([0,&nbsp;4,&nbsp;8])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;b.cumsum(axis=1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;cumulative&nbsp;sum&nbsp;along&nbsp;each&nbsp;row
array([[&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;3,&nbsp;&nbsp;6],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4,&nbsp;&nbsp;9,&nbsp;15,&nbsp;22],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8,&nbsp;17,&nbsp;27,&nbsp;38]])
</pre><p class="ql-align-center"><br></p><p class="ql-align-center"><strong>索引、截取和迭代</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">一维数组可以被索引、截取（Slicing）和迭代，就像 Python 列表和元组一样。注意其中 a[0:6:2] 表示从第 1 到第 6 个元素，并对每两个中的第二个元素进行操作。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(10)**3
&gt;&gt;&gt;&nbsp;a
array([&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;1,&nbsp;&nbsp;&nbsp;8,&nbsp;&nbsp;27,&nbsp;&nbsp;64,&nbsp;125,&nbsp;216,&nbsp;343,&nbsp;512,&nbsp;729])
&gt;&gt;&gt;&nbsp;a[2]
8
&gt;&gt;&gt;&nbsp;a[2:5]
array([&nbsp;8,&nbsp;27,&nbsp;64])
&gt;&gt;&gt;&nbsp;a[:6:2]&nbsp;=&nbsp;-1000&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;equivalent&nbsp;to&nbsp;a[0:6:2]&nbsp;=&nbsp;-1000;&nbsp;from&nbsp;start&nbsp;to&nbsp;position&nbsp;6,&nbsp;exclusive,&nbsp;set&nbsp;every&nbsp;2nd&nbsp;element&nbsp;to&nbsp;-1000
&gt;&gt;&gt;&nbsp;a
array([-1000,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,&nbsp;-1000,&nbsp;&nbsp;&nbsp;&nbsp;27,&nbsp;-1000,&nbsp;&nbsp;&nbsp;125,&nbsp;&nbsp;&nbsp;216,&nbsp;&nbsp;&nbsp;343,&nbsp;&nbsp;&nbsp;512,&nbsp;&nbsp;&nbsp;729])
&gt;&gt;&gt;&nbsp;a[&nbsp;:&nbsp;:-1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;reversed&nbsp;a
array([&nbsp;&nbsp;729,&nbsp;&nbsp;&nbsp;512,&nbsp;&nbsp;&nbsp;343,&nbsp;&nbsp;&nbsp;216,&nbsp;&nbsp;&nbsp;125,&nbsp;-1000,&nbsp;&nbsp;&nbsp;&nbsp;27,&nbsp;-1000,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,&nbsp;-1000])
&gt;&gt;&gt;&nbsp;for&nbsp;i&nbsp;in&nbsp;a:
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(i**(1/3.))
...
nan
1.0
nan
3.0
nan
5.0
6.0
7.0
8.0
9.0

</pre><p class="ql-align-justify">多维数组每个轴都可以有一个索引。这些索引在元组中用逗号分隔：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;def&nbsp;f(x,y):
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;10*x+y
...
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.fromfunction(f,(5,4),dtype=int)
&gt;&gt;&gt;&nbsp;b
array([[&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;2,&nbsp;&nbsp;3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[10,&nbsp;11,&nbsp;12,&nbsp;13],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[20,&nbsp;21,&nbsp;22,&nbsp;23],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[30,&nbsp;31,&nbsp;32,&nbsp;33],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[40,&nbsp;41,&nbsp;42,&nbsp;43]])
&gt;&gt;&gt;&nbsp;b[2,3]
23
&gt;&gt;&gt;&nbsp;b[0:5,&nbsp;1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;each&nbsp;row&nbsp;in&nbsp;the&nbsp;second&nbsp;column&nbsp;of&nbsp;b
array([&nbsp;1,&nbsp;11,&nbsp;21,&nbsp;31,&nbsp;41])
&gt;&gt;&gt;&nbsp;b[&nbsp;:&nbsp;,1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;equivalent&nbsp;to&nbsp;the&nbsp;previous&nbsp;example
array([&nbsp;1,&nbsp;11,&nbsp;21,&nbsp;31,&nbsp;41])
&gt;&gt;&gt;&nbsp;b[1:3,&nbsp;:&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;each&nbsp;column&nbsp;in&nbsp;the&nbsp;second&nbsp;and&nbsp;third&nbsp;row&nbsp;of&nbsp;b
array([[10,&nbsp;11,&nbsp;12,&nbsp;13],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[20,&nbsp;21,&nbsp;22,&nbsp;23]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">当有些维度没有指定索引时，空缺的维度被默认为取所有元素。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;b[-1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;last&nbsp;row.&nbsp;Equivalent&nbsp;to&nbsp;b[-1,:]
array([40,&nbsp;41,&nbsp;42,&nbsp;43])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">如上因为省略了第二维，b[i] 表示输出第 i 行。当然我们也可以用「:」表示省略的维度，例如 b[i] 等价于 b[i, :]。此外，NumPy 还允许使用 dots (...) 表示足够多的冒号来构建完整的索引元组。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">比如，如果 x 是 5 维数组：</p><p class="ql-align-justify"><br></p><ul><li class="ql-align-justify">x[1,2,...] 等于 x[1,2,:,:,:],</li><li class="ql-align-justify">x[...,3] 等于 x[:,:,:,:,3]&nbsp;</li><li class="ql-align-justify">x[4,...,5,:] 等于 x[4,:,:,5,:]</li></ul><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;np.array(&nbsp;[[[&nbsp;&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;a&nbsp;3D&nbsp;array&nbsp;(two&nbsp;stacked&nbsp;2D&nbsp;arrays)
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;10,&nbsp;12,&nbsp;13]],
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[100,101,102],
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[110,112,113]]])
&gt;&gt;&gt;&nbsp;c.shape
(2,&nbsp;2,&nbsp;3)
&gt;&gt;&gt;&nbsp;c[1,...]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;same&nbsp;as&nbsp;c[1,:,:]&nbsp;or&nbsp;c[1]
array([[100,&nbsp;101,&nbsp;102],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[110,&nbsp;112,&nbsp;113]])
&gt;&gt;&gt;&nbsp;c[...,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;same&nbsp;as&nbsp;c[:,:,2]
array([[&nbsp;&nbsp;2,&nbsp;&nbsp;13],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[102,&nbsp;113]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">多维数组中的迭代以第一条轴为参照完成，如下每一次循环都输出一个 b[i]：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;for&nbsp;row&nbsp;in&nbsp;b:
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(row)
...
[0&nbsp;1&nbsp;2&nbsp;3]
[10&nbsp;11&nbsp;12&nbsp;13]
[20&nbsp;21&nbsp;22&nbsp;23]
[30&nbsp;31&nbsp;32&nbsp;33]
[40&nbsp;41&nbsp;42&nbsp;43]
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">然而，如果想在数组的每个元素上进行操作，可以用 flat 方法。flat 是一个在数组所有元素中运算的迭代器，如下将逐元素地对数组进行操作。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;for&nbsp;element&nbsp;in&nbsp;b.flat:
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(element)
...
0
1
2
3
10
11
12
13
20
21
22
23
30
31
32
33
40
41
42
43

</pre><p class="ql-align-center"><strong>Shape 变换</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>改变数组的 shape</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">一个数组的 shape 是由轴及其元素数量决定的，它一般由一个整型元组表示，且元组中的整数表示对应维度的元素数。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.floor(10*np.random.random((3,4)))
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;2.,&nbsp;&nbsp;8.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4.,&nbsp;&nbsp;5.,&nbsp;&nbsp;1.,&nbsp;&nbsp;1.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8.,&nbsp;&nbsp;9.,&nbsp;&nbsp;3.,&nbsp;&nbsp;6.]])
&gt;&gt;&gt;&nbsp;a.shape
(3,&nbsp;4)
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">一个数组的 shape 可以由许多方法改变。例如以下三种方法都可输出一个改变 shape 后的新数组，它们都不会改变原数组。其中 reshape 方法在实践中会经常用到，因为我们需要改变数组的维度以执行不同的运算。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a.ravel()&nbsp;&nbsp;#&nbsp;returns&nbsp;the&nbsp;array,&nbsp;flattened
array([&nbsp;2.,&nbsp;&nbsp;8.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.,&nbsp;&nbsp;4.,&nbsp;&nbsp;5.,&nbsp;&nbsp;1.,&nbsp;&nbsp;1.,&nbsp;&nbsp;8.,&nbsp;&nbsp;9.,&nbsp;&nbsp;3.,&nbsp;&nbsp;6.])
&gt;&gt;&gt;&nbsp;a.reshape(6,2)&nbsp;&nbsp;#&nbsp;returns&nbsp;the&nbsp;array&nbsp;with&nbsp;a&nbsp;modified&nbsp;shape
array([[&nbsp;2.,&nbsp;&nbsp;8.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;6.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4.,&nbsp;&nbsp;5.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;1.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8.,&nbsp;&nbsp;9.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;3.,&nbsp;&nbsp;6.]])
&gt;&gt;&gt;&nbsp;a.T&nbsp;&nbsp;#&nbsp;returns&nbsp;the&nbsp;array,&nbsp;transposed
array([[&nbsp;2.,&nbsp;&nbsp;4.,&nbsp;&nbsp;8.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8.,&nbsp;&nbsp;5.,&nbsp;&nbsp;9.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;1.,&nbsp;&nbsp;3.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;6.,&nbsp;&nbsp;1.,&nbsp;&nbsp;6.]])
&gt;&gt;&gt;&nbsp;a.T.shape
(4,&nbsp;3)
&gt;&gt;&gt;&nbsp;a.shape
(3,&nbsp;4)
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">ravel() 和 flatten() 都是将多维数组降位一维，flatten() 返回一份新的数组，且对它所做的修改不会影响原始数组，而 ravel() 返回的是 view，会影响原始矩阵。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">在矩阵的转置中，行和列的维度将交换，且矩阵中每一个元素将沿主对角线对称变换。此外，reshape 如下所示返回修改过维度的新数组，而 resize 方法将直接修改原数组本身的维度。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a
array([[&nbsp;2.,&nbsp;&nbsp;8.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4.,&nbsp;&nbsp;5.,&nbsp;&nbsp;1.,&nbsp;&nbsp;1.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8.,&nbsp;&nbsp;9.,&nbsp;&nbsp;3.,&nbsp;&nbsp;6.]])
&gt;&gt;&gt;&nbsp;a.resize((2,6))
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;2.,&nbsp;&nbsp;8.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.,&nbsp;&nbsp;4.,&nbsp;&nbsp;5.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;1.,&nbsp;&nbsp;8.,&nbsp;&nbsp;9.,&nbsp;&nbsp;3.,&nbsp;&nbsp;6.]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">如果在 shape 变换中一个维度设为-1，那么这一个维度包含的元素数将会被自动计算。如下所示，a 一共有 12 个元素，在确定一共有 3 行后，-1 会自动计算出应该需要 4 列才能安排所有的元素。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a.reshape(3,-1)
array([[&nbsp;2.,&nbsp;&nbsp;8.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4.,&nbsp;&nbsp;5.,&nbsp;&nbsp;1.,&nbsp;&nbsp;1.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8.,&nbsp;&nbsp;9.,&nbsp;&nbsp;3.,&nbsp;&nbsp;6.]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>数组堆叠</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">数组可以在不同轴上被堆叠在一起。如下所示 vstack 将在第二个维度（垂直）将两个数组拼接在一起，而 hstack 将在第一个维度（水平）将数组拼接在一起。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.floor(10*np.random.random((2,2)))
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;8.,&nbsp;&nbsp;8.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.]])
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.floor(10*np.random.random((2,2)))
&gt;&gt;&gt;&nbsp;b
array([[&nbsp;1.,&nbsp;&nbsp;8.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;4.]])
&gt;&gt;&gt;&nbsp;np.vstack((a,b))
array([[&nbsp;8.,&nbsp;&nbsp;8.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;8.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;4.]])
&gt;&gt;&gt;&nbsp;np.hstack((a,b))
array([[&nbsp;8.,&nbsp;&nbsp;8.,&nbsp;&nbsp;1.,&nbsp;&nbsp;8.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;4.]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">column_stack 函数可堆叠一维数组为二维数组的列，作用相等于针对二维数组的 hstack 函数。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;from&nbsp;numpy&nbsp;import&nbsp;newaxis
&gt;&gt;&gt;&nbsp;np.column_stack((a,b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;with&nbsp;2D&nbsp;arrays
array([[&nbsp;8.,&nbsp;&nbsp;8.,&nbsp;&nbsp;1.,&nbsp;&nbsp;8.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;4.]])
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([4.,2.])
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([3.,8.])
&gt;&gt;&gt;&nbsp;np.column_stack((a,b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;returns&nbsp;a&nbsp;2D&nbsp;array
array([[&nbsp;4.,&nbsp;3.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.,&nbsp;8.]])
&gt;&gt;&gt;&nbsp;np.hstack((a,b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;result&nbsp;is&nbsp;different
array([&nbsp;4.,&nbsp;2.,&nbsp;3.,&nbsp;8.])
&gt;&gt;&gt;&nbsp;a[:,newaxis]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;this&nbsp;allows&nbsp;to&nbsp;have&nbsp;a&nbsp;2D&nbsp;columns&nbsp;vector
array([[&nbsp;4.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.]])
&gt;&gt;&gt;&nbsp;np.column_stack((a[:,newaxis],b[:,newaxis]))
array([[&nbsp;4.,&nbsp;&nbsp;3.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.,&nbsp;&nbsp;8.]])
&gt;&gt;&gt;&nbsp;np.hstack((a[:,newaxis],b[:,newaxis]))&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;result&nbsp;is&nbsp;the&nbsp;same
array([[&nbsp;4.,&nbsp;&nbsp;3.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.,&nbsp;&nbsp;8.]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">与 column_stack 相似，row_stack 函数相等于二维数组中的 vstack。一般在高于二维的情况中，hstack 沿第二个维度堆叠、vstack 沿第一个维度堆叠，而 concatenate 更进一步可以在任意给定的维度上堆叠两个数组，当然这要求其它维度的长度都相等。concatenate 在很多深度模型中都有应用，例如权重矩阵的堆叠或 DenseNet 特征图的堆叠。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">在复杂情况中，r_ 和 c_ 可以有效地在创建数组时帮助沿着一条轴堆叠数值，它们同样允许使用范围迭代「:」生成数组。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;np.r_[1:4,0,4]
array([1,&nbsp;2,&nbsp;3,&nbsp;0,&nbsp;4])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">当用数组为参数时，r_ 和 c_ 在默认行为下与 vstack 和 hstack 相似，但它们如 concatenate 一样允许给定需要堆叠的维度。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>拆分数组</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">使用 hsplit 可以顺着水平轴拆分一个数组，我们指定切分后输出的数组数，或指定在哪一列拆分数组：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.floor(10*np.random.random((2,12)))
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;9.,&nbsp;&nbsp;5.,&nbsp;&nbsp;6.,&nbsp;&nbsp;3.,&nbsp;&nbsp;6.,&nbsp;&nbsp;8.,&nbsp;&nbsp;0.,&nbsp;&nbsp;7.,&nbsp;&nbsp;9.,&nbsp;&nbsp;7.,&nbsp;&nbsp;2.,&nbsp;&nbsp;7.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;4.,&nbsp;&nbsp;9.,&nbsp;&nbsp;2.,&nbsp;&nbsp;2.,&nbsp;&nbsp;1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.,&nbsp;&nbsp;2.,&nbsp;&nbsp;2.,&nbsp;&nbsp;4.,&nbsp;&nbsp;0.]])
&gt;&gt;&gt;&nbsp;np.hsplit(a,3)&nbsp;&nbsp;&nbsp;#&nbsp;Split&nbsp;a&nbsp;into&nbsp;3
[array([[&nbsp;9.,&nbsp;&nbsp;5.,&nbsp;&nbsp;6.,&nbsp;&nbsp;3.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;4.,&nbsp;&nbsp;9.,&nbsp;&nbsp;2.]]),&nbsp;array([[&nbsp;6.,&nbsp;&nbsp;8.,&nbsp;&nbsp;0.,&nbsp;&nbsp;7.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.,&nbsp;&nbsp;1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.]]),&nbsp;array([[&nbsp;9.,&nbsp;&nbsp;7.,&nbsp;&nbsp;2.,&nbsp;&nbsp;7.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.,&nbsp;&nbsp;2.,&nbsp;&nbsp;4.,&nbsp;&nbsp;0.]])]
&gt;&gt;&gt;&nbsp;np.hsplit(a,(3,4))&nbsp;&nbsp;&nbsp;#&nbsp;Split&nbsp;a&nbsp;after&nbsp;the&nbsp;third&nbsp;and&nbsp;the&nbsp;fourth&nbsp;column
[array([[&nbsp;9.,&nbsp;&nbsp;5.,&nbsp;&nbsp;6.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;4.,&nbsp;&nbsp;9.]]),&nbsp;array([[&nbsp;3.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.]]),&nbsp;array([[&nbsp;6.,&nbsp;&nbsp;8.,&nbsp;&nbsp;0.,&nbsp;&nbsp;7.,&nbsp;&nbsp;9.,&nbsp;&nbsp;7.,&nbsp;&nbsp;2.,&nbsp;&nbsp;7.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.,&nbsp;&nbsp;1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.,&nbsp;&nbsp;2.,&nbsp;&nbsp;2.,&nbsp;&nbsp;4.,&nbsp;&nbsp;0.]])]
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">vsplit 沿着垂直轴拆分，array_split 可指定顺着哪一条轴拆分。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-center"><strong>复制与 views</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">在进行数组运算或操作时，入门者经常很难判断数据到底是复制到了新的数组还是直接在原始数据上修改。这对进一步的运算有很大的影响，因此有时候我们也需要复制内容到新的变量内存中，而不能仅将新变量指向原内存。目前一般有三种复制方法，即不复制内存、浅复制以及深复制。</p><p class="ql-align-center"><br></p><p class="ql-align-justify"><strong>实际不复制</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">简单的任务并不会复制数组目标或它们的数据，如下先把变量 a 赋值于 b，然后修改变量 b 就会同时修改变量 a，这种一般的赋值方法会令变量间具有关联性。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(12)
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;no&nbsp;new&nbsp;object&nbsp;is&nbsp;created
&gt;&gt;&gt;&nbsp;b&nbsp;is&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;a&nbsp;and&nbsp;b&nbsp;are&nbsp;two&nbsp;names&nbsp;for&nbsp;the&nbsp;same&nbsp;ndarray&nbsp;object
True
&gt;&gt;&gt;&nbsp;b.shape&nbsp;=&nbsp;3,4&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;changes&nbsp;the&nbsp;shape&nbsp;of&nbsp;a
&gt;&gt;&gt;&nbsp;a.shape
(3,&nbsp;4)
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">Pythan 将不定对象作为参照（references）传递，所以调用函数不会产生目标识别符的变化，也不会发生实际的内容复制。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;def&nbsp;f(x):
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(id(x))
...
&gt;&gt;&gt;&nbsp;id(a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;id&nbsp;is&nbsp;a&nbsp;unique&nbsp;identifier&nbsp;of&nbsp;an&nbsp;object
148293216
&gt;&gt;&gt;&nbsp;f(a)
148293216

</pre><p class="ql-align-justify"><strong>View 或浅复制</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">不同数组对象可以共享相同数据，view 方法可以创建一个新数组对象来查看相同数据。如下 c 和 a 的目标识别符并不一致，且改变其中一个变量的 shape 并不会对应改变另一个。但这两个数组是共享所有元素的，所以改变一个数组的某个元素同样会改变另一个数组的对应元素。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;a.view()
&gt;&gt;&gt;&nbsp;c&nbsp;is&nbsp;a
False
&gt;&gt;&gt;&nbsp;c.base&nbsp;is&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;c&nbsp;is&nbsp;a&nbsp;view&nbsp;of&nbsp;the&nbsp;data&nbsp;owned&nbsp;by&nbsp;a
True
&gt;&gt;&gt;&nbsp;c.flags.owndata
False
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;c.shape&nbsp;=&nbsp;2,6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;a's&nbsp;shape&nbsp;doesn't&nbsp;change
&gt;&gt;&gt;&nbsp;a.shape
(3,&nbsp;4)
&gt;&gt;&gt;&nbsp;c[0,4]&nbsp;=&nbsp;1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;a's&nbsp;data&nbsp;changes
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1234,&nbsp;&nbsp;&nbsp;&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;6,&nbsp;&nbsp;&nbsp;&nbsp;7],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;8,&nbsp;&nbsp;&nbsp;&nbsp;9,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;11]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">分割数组输出的是它的一个 view，如下将数组 a 分割为子数组 s，那么 s 就是 a 的一个 view，修改 s 中的元素同样会修改 a 中对应的元素。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;s&nbsp;=&nbsp;a[&nbsp;:&nbsp;,&nbsp;1:3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;spaces&nbsp;added&nbsp;for&nbsp;clarity;&nbsp;could&nbsp;also&nbsp;be&nbsp;written&nbsp;"s&nbsp;=&nbsp;a[:,1:3]"
&gt;&gt;&gt;&nbsp;s[:]&nbsp;=&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;s[:]&nbsp;is&nbsp;a&nbsp;view&nbsp;of&nbsp;s.&nbsp;Note&nbsp;the&nbsp;difference&nbsp;between&nbsp;s=10&nbsp;and&nbsp;s[:]=10
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;&nbsp;3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1234,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;&nbsp;7],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;8,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;11]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>深复制</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">copy 方法可完整地复制数组及数据，这种赋值方法会令两个变量有不一样的数组目标，且数据不共享。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;d&nbsp;=&nbsp;a.copy()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;a&nbsp;new&nbsp;array&nbsp;object&nbsp;with&nbsp;new&nbsp;data&nbsp;is&nbsp;created
&gt;&gt;&gt;&nbsp;d&nbsp;is&nbsp;a
False
&gt;&gt;&gt;&nbsp;d.base&nbsp;is&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;d&nbsp;doesn't&nbsp;share&nbsp;anything&nbsp;with&nbsp;a
False
&gt;&gt;&gt;&nbsp;d[0,0]&nbsp;=&nbsp;9999
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;&nbsp;3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1234,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;&nbsp;7],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;&nbsp;8,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;11]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-center"><strong>深入理解 NumPy</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>广播机制</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">广播操作是 NumPy 非常重要的一个特点，它允许 NumPy 扩展矩阵间的运算。例如它会隐式地把一个数组的异常维度调整到与另一个算子相匹配的维度以实现维度兼容。例如将一个维度为 [3,2] 的矩阵与另一个维度为 [3,1] 的矩阵相加是合法的，NumPy 会自动将第二个矩阵扩展到等同的维度。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">为了定义两个形状是否是可兼容的，NumPy 从最后开始往前逐个比较它们的维度大小。在这个过程中，如果两者的对应维度相同，或者其一（或者全是）等于 1，则继续进行比较，直到最前面的维度。若不满足这两个条件，程序就会报错。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">如下展示了一个广播操作：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;a&nbsp;=&nbsp;np.array([1.0,2.0,3.0,4.0,&nbsp;5.0,&nbsp;6.0]).reshape(3,2)
&gt;&gt;&gt;b&nbsp;=&nbsp;np.array([3.0])
&gt;&gt;&gt;a&nbsp;*&nbsp;b

array([[&nbsp;&nbsp;3.,&nbsp;&nbsp;&nbsp;6.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;9.,&nbsp;&nbsp;12.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;15.,&nbsp;&nbsp;18.]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-center"><strong>高级索引</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">NumPy 比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和截取的索引，数组可以由整数数组和布尔数组 indexed。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>通过数组索引</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">如下我们可以根据数组 i 和 j 索引数组 a 中间的元素，其中输出数组保持索引的 shape。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(12)**2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;first&nbsp;12&nbsp;square&nbsp;numbers
&gt;&gt;&gt;&nbsp;i&nbsp;=&nbsp;np.array(&nbsp;[&nbsp;1,1,3,8,5&nbsp;]&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;an&nbsp;array&nbsp;of&nbsp;indices
&gt;&gt;&gt;&nbsp;a[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;elements&nbsp;of&nbsp;a&nbsp;at&nbsp;the&nbsp;positions&nbsp;i
array([&nbsp;1,&nbsp;&nbsp;1,&nbsp;&nbsp;9,&nbsp;64,&nbsp;25])

&gt;&gt;&gt;&nbsp;j&nbsp;=&nbsp;np.array(&nbsp;[&nbsp;[&nbsp;3,&nbsp;4],&nbsp;[&nbsp;9,&nbsp;7&nbsp;]&nbsp;]&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;a&nbsp;bidimensional&nbsp;array&nbsp;of&nbsp;indices
&gt;&gt;&gt;&nbsp;a[j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;same&nbsp;shape&nbsp;as&nbsp;j
array([[&nbsp;9,&nbsp;16],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[81,&nbsp;49]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">当使用多维数组作为索引时，每一个维度就会索引一次原数组，并按索引的 shape 排列。下面的代码展示了这种索引方式，palette 可以视为简单的调色板，而数组 image 中的元素则表示索引对应颜色的像素点。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;palette&nbsp;=&nbsp;np.array(&nbsp;[&nbsp;[0,0,0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;black
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[255,0,0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;red
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,255,0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;green
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,0,255],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;blue
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[255,255,255]&nbsp;]&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;white
&gt;&gt;&gt;&nbsp;image&nbsp;=&nbsp;np.array(&nbsp;[&nbsp;[&nbsp;0,&nbsp;1,&nbsp;2,&nbsp;0&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;each&nbsp;value&nbsp;corresponds&nbsp;to&nbsp;a&nbsp;color&nbsp;in&nbsp;the&nbsp;palette
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0,&nbsp;3,&nbsp;4,&nbsp;0&nbsp;]&nbsp;&nbsp;]&nbsp;)
&gt;&gt;&gt;&nbsp;palette[image]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;(2,4,3)&nbsp;color&nbsp;image
array([[[&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[255,&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0,&nbsp;255,&nbsp;&nbsp;&nbsp;0],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0,&nbsp;255],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[255,&nbsp;255,&nbsp;255],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0]]])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[81,&nbsp;49]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">我们也可以使用多维索引获取数组中的元素，多维索引的每个维度都必须有相同的形状。如下多维数组 i 和 j 可以分别作为索引 a 中第一个维度和第二个维度的参数，例如 a[i, j] 分别从 i 和 j 中抽取一个元素作为索引 a 中元素的参数。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(12).reshape(3,4)
&gt;&gt;&gt;&nbsp;a
array([[&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;2,&nbsp;&nbsp;3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4,&nbsp;&nbsp;5,&nbsp;&nbsp;6,&nbsp;&nbsp;7],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8,&nbsp;&nbsp;9,&nbsp;10,&nbsp;11]])
&gt;&gt;&gt;&nbsp;i&nbsp;=&nbsp;np.array(&nbsp;[&nbsp;[0,1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;indices&nbsp;for&nbsp;the&nbsp;first&nbsp;dim&nbsp;of&nbsp;a
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,2]&nbsp;]&nbsp;)
&gt;&gt;&gt;&nbsp;j&nbsp;=&nbsp;np.array(&nbsp;[&nbsp;[2,1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;indices&nbsp;for&nbsp;the&nbsp;second&nbsp;dim
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,3]&nbsp;]&nbsp;)
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;i&nbsp;and&nbsp;j&nbsp;must&nbsp;have&nbsp;equal&nbsp;shape
array([[&nbsp;2,&nbsp;&nbsp;5],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;7,&nbsp;11]])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;a[i,2]
array([[&nbsp;2,&nbsp;&nbsp;6],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;6,&nbsp;10]])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;a[:,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;i.e.,&nbsp;a[&nbsp;:&nbsp;,&nbsp;j]
array([[[&nbsp;2,&nbsp;&nbsp;1],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;3,&nbsp;&nbsp;3]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;6,&nbsp;&nbsp;5],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;7,&nbsp;&nbsp;7]],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[10,&nbsp;&nbsp;9],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;11]]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">同样，我们把 i 和 j 放在一个序列中，然后用它作为索引：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;l&nbsp;=&nbsp;[i,j]
&gt;&gt;&gt;&nbsp;a[l]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;equivalent&nbsp;to&nbsp;a[i,j]
array([[&nbsp;2,&nbsp;&nbsp;5],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;7,&nbsp;11]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">然而，我们不能如上把 i 和 j 放在一个数组中作为索引，因为数组会被理解为索引 a 的第一维度。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;s&nbsp;=&nbsp;np.array(&nbsp;[i,j]&nbsp;)
&gt;&gt;&gt;&nbsp;a[s]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;not&nbsp;what&nbsp;we&nbsp;want
Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):
&nbsp;&nbsp;File&nbsp;"&lt;stdin&gt;",&nbsp;line&nbsp;1,&nbsp;in&nbsp;?
IndexError:&nbsp;index&nbsp;(3)&nbsp;out&nbsp;of&nbsp;range&nbsp;(0&lt;=index&lt;=2)&nbsp;in&nbsp;dimension&nbsp;0
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;a[tuple(s)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;same&nbsp;as&nbsp;a[i,j]
array([[&nbsp;2,&nbsp;&nbsp;5],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;7,&nbsp;11]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">另一个将数组作为索引的常用方法是搜索时间序列的最大值：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;time&nbsp;=&nbsp;np.linspace(20,&nbsp;145,&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;time&nbsp;scale
&gt;&gt;&gt;&nbsp;data&nbsp;=&nbsp;np.sin(np.arange(20)).reshape(5,4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;4&nbsp;time-dependent&nbsp;series
&gt;&gt;&gt;&nbsp;time
array([&nbsp;&nbsp;20.&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;51.25,&nbsp;&nbsp;&nbsp;82.5&nbsp;,&nbsp;&nbsp;113.75,&nbsp;&nbsp;145.&nbsp;&nbsp;])
&gt;&gt;&gt;&nbsp;data
array([[&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.84147098,&nbsp;&nbsp;0.90929743,&nbsp;&nbsp;0.14112001],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.7568025&nbsp;,&nbsp;-0.95892427,&nbsp;-0.2794155&nbsp;,&nbsp;&nbsp;0.6569866&nbsp;],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.98935825,&nbsp;&nbsp;0.41211849,&nbsp;-0.54402111,&nbsp;-0.99999021],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.53657292,&nbsp;&nbsp;0.42016704,&nbsp;&nbsp;0.99060736,&nbsp;&nbsp;0.65028784],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.28790332,&nbsp;-0.96139749,&nbsp;-0.75098725,&nbsp;&nbsp;0.14987721]])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;ind&nbsp;=&nbsp;data.argmax(axis=0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;index&nbsp;of&nbsp;the&nbsp;maxima&nbsp;for&nbsp;each&nbsp;series
&gt;&gt;&gt;&nbsp;ind
array([2,&nbsp;0,&nbsp;3,&nbsp;1])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;time_max&nbsp;=&nbsp;time[ind]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;times&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;maxima
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;data_max&nbsp;=&nbsp;data[ind,&nbsp;range(data.shape[1])]&nbsp;#&nbsp;=&gt;&nbsp;data[ind[0],0],&nbsp;data[ind[1],1]...
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;time_max
array([&nbsp;&nbsp;82.5&nbsp;,&nbsp;&nbsp;&nbsp;20.&nbsp;&nbsp;,&nbsp;&nbsp;113.75,&nbsp;&nbsp;&nbsp;51.25])
&gt;&gt;&gt;&nbsp;data_max
array([&nbsp;0.98935825,&nbsp;&nbsp;0.84147098,&nbsp;&nbsp;0.99060736,&nbsp;&nbsp;0.6569866&nbsp;])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;np.all(data_max&nbsp;==&nbsp;data.max(axis=0))
True

</pre><p class="ql-align-justify">你也可以用数组索引作为一个分配目标：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(5)
&gt;&gt;&gt;&nbsp;a
array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4])
&gt;&gt;&gt;&nbsp;a[[1,3,4]]&nbsp;=&nbsp;0
&gt;&gt;&gt;&nbsp;a
array([0,&nbsp;0,&nbsp;2,&nbsp;0,&nbsp;0])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">然而，当索引列表中有重复时，赋值任务会执行多次，并保留最后一次结果。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(5)
&gt;&gt;&gt;&nbsp;a[[0,0,2]]=[1,2,3]
&gt;&gt;&gt;&nbsp;a
array([2,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">这是合理的，但注意如果你使用 Python 的 +=创建，可能不会得出预期的结果：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(5)
&gt;&gt;&gt;&nbsp;a[[0,0,2]]+=1
&gt;&gt;&gt;&nbsp;a
array([1,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">虽然 0 在索引列表中出现两次，第 0 个元素只会增加一次。这是因为 Python 中「a+=1」等于「a = a + 1」.</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>用布尔数组做索引</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">当我们索引数组元素时，我们在提供索引列表。但布尔值索引是不同的，我们需要清楚地选择被索引数组中哪个元素是我们想要的哪个是不想要的。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">布尔索引需要用和原数组相同 shape 的布尔值数组，如下只有在大于 4 的情况下才输出 True，而得出来的布尔值数组可作为索引。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(12).reshape(3,4)
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;a&nbsp;&gt;&nbsp;4
&gt;&gt;&gt;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;b&nbsp;is&nbsp;a&nbsp;boolean&nbsp;with&nbsp;a's&nbsp;shape
array([[False,&nbsp;False,&nbsp;False,&nbsp;False],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[False,&nbsp;&nbsp;True,&nbsp;&nbsp;True,&nbsp;&nbsp;True],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;True,&nbsp;&nbsp;True,&nbsp;&nbsp;True,&nbsp;&nbsp;True]])
&gt;&gt;&gt;&nbsp;a[b]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;1d&nbsp;array&nbsp;with&nbsp;the&nbsp;selected&nbsp;elements
array([&nbsp;5,&nbsp;&nbsp;6,&nbsp;&nbsp;7,&nbsp;&nbsp;8,&nbsp;&nbsp;9,&nbsp;10,&nbsp;11])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">这个性质在任务中非常有用，例如在 ReLu 激活函数中，只有大于 0 才输出激活值，因此我们就能使用这种方式实现 ReLU 激活函数。</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a[b]&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;All&nbsp;elements&nbsp;of&nbsp;'a'&nbsp;higher&nbsp;than&nbsp;4&nbsp;become&nbsp;0
&gt;&gt;&gt;&nbsp;a
array([[0,&nbsp;1,&nbsp;2,&nbsp;3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;0,&nbsp;0,&nbsp;0],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0]])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">第二种使用布尔索引的方法与整数索引更加相似的；在数组的每个维度中，我们使用一维布尔数组选择我们想要的截取部分：</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(12).reshape(3,4)
&gt;&gt;&gt;&nbsp;b1&nbsp;=&nbsp;np.array([False,True,True])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;first&nbsp;dim&nbsp;selection
&gt;&gt;&gt;&nbsp;b2&nbsp;=&nbsp;np.array([True,False,True,False])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;second&nbsp;dim&nbsp;selection
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;a[b1,:]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;selecting&nbsp;rows
array([[&nbsp;4,&nbsp;&nbsp;5,&nbsp;&nbsp;6,&nbsp;&nbsp;7],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8,&nbsp;&nbsp;9,&nbsp;10,&nbsp;11]])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;a[b1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;same&nbsp;thing
array([[&nbsp;4,&nbsp;&nbsp;5,&nbsp;&nbsp;6,&nbsp;&nbsp;7],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8,&nbsp;&nbsp;9,&nbsp;10,&nbsp;11]])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;a[:,b2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;selecting&nbsp;columns
array([[&nbsp;0,&nbsp;&nbsp;2],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4,&nbsp;&nbsp;6],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;8,&nbsp;10]])
&gt;&gt;&gt;
&gt;&gt;&gt;&nbsp;a[b1,b2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;a&nbsp;weird&nbsp;thing&nbsp;to&nbsp;do
array([&nbsp;4,&nbsp;10])
</pre><p class="ql-align-justify"><br></p><p class="ql-align-justify">注意一维布尔数组的长度必须和想截取轴的长度相同。在上面的例子中，b1 的长度 3、b2 的长度为 4，它们分别对应于 a 的第一个维度与第二个维度。</p><p class="ql-align-justify"><br></p><p class="ql-align-center"><strong>线性代数</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>简单的数组运算</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">如下仅展示了简单的矩阵运算更多详细的方法可在实践中遇到在查找 API。如下展示了矩阵的转置、求逆、单位矩阵、矩阵乘法、矩阵的迹、解线性方程和求特征向量等基本运算：</p><p class="ql-align-justify"><br></p><pre class="ql-syntax ql-align-justify" spellcheck="false">&gt;&gt;&gt;&nbsp;import&nbsp;numpy&nbsp;as&nbsp;np
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;2.0],&nbsp;[3.0,&nbsp;4.0]])
&gt;&gt;&gt;&nbsp;print(a)
[[&nbsp;1.&nbsp;&nbsp;2.]
&nbsp;[&nbsp;3.&nbsp;&nbsp;4.]]

&gt;&gt;&gt;&nbsp;a.transpose()
array([[&nbsp;1.,&nbsp;&nbsp;3.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.,&nbsp;&nbsp;4.]])

&gt;&gt;&gt;&nbsp;np.linalg.inv(a)
array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])

&gt;&gt;&gt;&nbsp;u&nbsp;=&nbsp;np.eye(2)&nbsp;#&nbsp;unit&nbsp;2x2&nbsp;matrix;&nbsp;"eye"&nbsp;represents&nbsp;"I"
&gt;&gt;&gt;&nbsp;u
array([[&nbsp;1.,&nbsp;&nbsp;0.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;1.]])
&gt;&gt;&gt;&nbsp;j&nbsp;=&nbsp;np.array([[0.0,&nbsp;-1.0],&nbsp;[1.0,&nbsp;0.0]])

&gt;&gt;&gt;&nbsp;np.dot&nbsp;(j,&nbsp;j)&nbsp;#&nbsp;matrix&nbsp;product
array([[-1.,&nbsp;&nbsp;0.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;-1.]])

&gt;&gt;&gt;&nbsp;np.trace(u)&nbsp;&nbsp;#&nbsp;trace
2.0

&gt;&gt;&gt;&nbsp;y&nbsp;=&nbsp;np.array([[5.],&nbsp;[7.]])
&gt;&gt;&gt;&nbsp;np.linalg.solve(a,&nbsp;y)
array([[-3.],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4.]])

&gt;&gt;&gt;&nbsp;np.linalg.eig(j)
(array([&nbsp;0.+1.j,&nbsp;&nbsp;0.-1.j]),&nbsp;array([[&nbsp;0.70710678+0.j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.70710678-0.j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.00000000-0.70710678j,&nbsp;&nbsp;0.00000000+0.70710678j]]))

Parameters:
&nbsp;&nbsp;&nbsp;&nbsp;square&nbsp;matrix
Returns
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;eigenvalues,&nbsp;each&nbsp;repeated&nbsp;according&nbsp;to&nbsp;its&nbsp;multiplicity.
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;normalized&nbsp;(unit&nbsp;"length")&nbsp;eigenvectors,&nbsp;such&nbsp;that&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;column&nbsp;``v[:,i]``&nbsp;is&nbsp;the&nbsp;eigenvector&nbsp;corresponding&nbsp;to&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;eigenvalue&nbsp;``w[i]``&nbsp;.
</pre><p class="ql-align-center"><br></p><p><br></p><ul><li class="ql-align-justify"><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650741170&amp;idx=2&amp;sn=50df72d616eddb3176a735d805f39779&amp;scene=21#wechat_redirect" target="_blank" style="color: rgb(87, 107, 149);">数据科学初学者必知的NumPy基础知识</a></li><li class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650732472&amp;idx=4&amp;sn=1fe80480abdaf6f66c442d68e111cebf&amp;chksm=871b33c6b06cbad070ef7d336b44d8021f68129114155244866c6a5075d63a342c0481b7e9d3&amp;scene=21#wechat_redirect" target="_blank" style="color: rgb(87, 107, 149);">从数组到矩阵的迹，NumPy常见使用大总结</a></li></ul><p class="ql-align-justify"><br></p><p><em style="color: rgb(136, 136, 136);">原文档链接：https://docs.scipy.org/doc/numpy/user/quickstart.html</em></p><p class="ql-align-justify"><br></p><p><br></p>